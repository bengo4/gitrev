// Copyright 2019 Bengo4.com, Inc.
// Gitrev: generates const as revision id.
package main

import (
	"bytes"
	"flag"
	"go/parser"
	"go/token"
	"html/template"
	"io/ioutil"
	"log"
	"os/exec"
	"strings"

	"github.com/bengo4/erh"
)

const (
	outTmpl = `package {{.Package}}
// generated by gitrev
const Revision = "{{.Revision}}"
`
)

func main() {
	var (
		outFile   string
		constName string
	)
	flag.StringVar(&outFile, "out", "rev.go", "filename to generate")
	flag.StringVar(&constName, "constname", "Revision", "const name to hold a revision ID")
	flag.Parse()

	pkg, err := PackageName()
	if err != nil {
		log.Fatal(err)
		return
	}

	rev, err := GitRev()
	if err != nil {
		log.Fatal(err)
		return
	}

	data := struct {
		Package  string
		Revision string
	}{
		Package:  pkg,
		Revision: rev,
	}

	t, err := template.New("test").Parse(outTmpl)
	if err != nil {
		log.Fatal(err)
		return
	}

	out := new(bytes.Buffer)
	if err := t.Execute(out, data); err != nil {
		log.Fatal(err)
		return
	}

	if err := ioutil.WriteFile(outFile, out.Bytes(), 0777); err != nil {
		log.Fatal(err)
		return
	}

	log.Printf("%q has been generated.", outFile)
}

// PackageName gets a package name from Go source files in the working directory.
func PackageName() (string, error) {
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, ".", nil, parser.PackageClauseOnly)
	if err != nil {
		return "", erh.Wrap(err)
	}
	if len(pkgs) == 0 {
		return "", erh.Errorf("package not found")
	}

	pkgNames := []string{}
	for name := range pkgs {
		if strings.HasSuffix(name, "_test") {
			continue
		}

		pkgNames = append(pkgNames, name)
	}

	switch len(pkgNames) {
	case 0:
		return "", erh.Errorf("package not found")
	case 1:
		return pkgNames[0], nil
	default:
		return "", erh.Errorf("multiple packages found: %v", pkgNames)
	}
}

// GitRev gets a commit hash from HEAD of the working directory.
func GitRev() (string, error) {
	cmd := exec.Command("git", "rev-parse", "HEAD")
	stdOut := new(bytes.Buffer)
	stdErr := new(bytes.Buffer)
	cmd.Stdout = stdOut
	cmd.Stderr = stdErr

	if err := cmd.Run(); err != nil {
		return "", erh.Wrap(err, "%s", strings.TrimSpace(stdErr.String()))
	}

	return strings.TrimSpace(stdOut.String()), nil
}
